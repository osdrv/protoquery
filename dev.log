2024-07-13 - Avoid re-entring visited nodes

Assume the following root message:

R
  - L: [ A, B, C ]

Given a path: "//path", the root message visit sequence would be the following:

Assume, the path matches B.

0.  Schedule R with // {admit}
1.  Visit R with // {from 0}
2.  Schedule L with // {admit}
3.  Schedule L with path {admit}
4.  Visit L with // {from 2}
5.  Schedule L with path {skip/3}
6.  Schedule A with // {admit}
7.  Schedule B with // {admit}
8.  Schedule C with // {admit}
9.  Visit L with path {from 3} -> yields B
10. Visit A with // {from 6}
11. Schedule A with path {admit}
12. Visit B with // {from 7}
13. Schedule B with path {admit}
14. Visit C with // {from 8}
15. Schedule C with path {admit}
16. Visit A with path {from 10}
17. Visit B with path {from 11} -> yields B
18. Visit C with path {from 12}

The problem is in this double dispatch leading to a duplicated B in the response.

2024-07-12 - Recusrive descent lookup

Implementing // path operator (SlashSlash).

The algoritm is the following:
Given a root node R and a recursive descent path in a form: "//P".
    Note: Defining a root node A with a direct or indirect
    descending node B and a path in a form "A//B" is trivially
    equivalent to the statement above.
The selector algoritm should perform a recursive descent traversal
of the entire R node tree and collect all nodes (be it: messages,
list elements, map values) matching the selector P.

Consider the following node tree:
R
  - A
    - B
    - C
      - D
        - B
  - B
In this case the recursive descent selector must return all nodes
matching B in total (expanded paths: R/A/B, R/A/C/D/B, R/B).

2024-06-20 - Expression grammar

Expressions could be of 3 types:
* Boolean
* String
* Number(int64)

The following grammar would be used to parse expressions:
```
boolean = "true" | "false"
string = '"' [^"]* '"'
number = [0-9]+
identifier = [a-zA-Z_][a-zA-Z0-9_]*
literal = boolean | string | number
property = @identifier
function_call = identifier '(' [expression (',' expression)*] ')'
elementary_expression = literal | property | function_call | unary_expression | '(' expression ')'

unary_expression = unary_operator expression
unary_operator = "!" | "+" | "-"

expression = comparison_expression
comparison_expression = add_expression comparison_operator add_expression
add_expression = mul_expression add_operator mul_expression
mul_expression = elementary_expression mul_operator elementary_expression

comparison_operator = "=" | "!=" | "<" | "<=" | ">" | ">="
add_operator = "+" | "-", "&&", "||"
mul_operator = "*" | "/"

```


2024-06-18 - On KeyQueryStep and AttributeFilterQueryStep

Key operator is the most complicated step in XPath.

Syntax: `context[key_expression]`


There are effectively 3 distinct kinds of keys:
* Index keys.
    * Evaluates to an integer.
    * Resolves a list to a single element (or an empty set).
    * Examples:
        * "/foo[3]": 3rd element of foo.
        * "/foo[last()]": last element of foo.
        * "/foo[length() - 1]": another way to get the last element of foo.
* Filter keys.
    * Evaluates to a boolean.
    * Filters a list to another list.
    * Examples:
        * "/foo[@bar>10]": elements of foo with bar > 10.
        * "/foo[position() < 3]": first 2 elements of foo.
        * "/foo[position() > 3]": elements of foo after the first 3.
* Map keys.
    * Evaluates to a primitive that would be coalesced to the map key type.
    * Resolves a map to a single element (or an empty set).
    * Examples:
        * "/foo['baz']": map element of foo with a string key baz.
        * "/foo[true]": map element of foo with boolean key true.
        * "/foo[123 + 456]: map element of foo with a numeric key 579.

The following rules apply:
    * Filter keys are chainable.
        * "/foo[@bar>10][position() < 3]" works as AND.
    * Filter keys are element-contextual. The following operators are defined:
        * `.`: current node.
        * `..`: parent node.
        * `@`: attribute prefix.
        * `*`: any attribute.
        * last(): last index of the list.
        * position(): current index of the list element.
    * Index keys are list-contextual. The following operations are defined:
        * length(): length of the list.
        * last(): last index of the list.
        * position(): current index of the list element.
    * Expressions can resolve to one of the following types:
        * Boolean
        * String
        * Numeric

Given the syntax, determining the specific type of a key is a challenge.
In order to conclude the key kind, we use the evaluating expression type.

The following algorithm would be applied:
    * Numeric keys are either index or map keys.
        * A numeric key expression would be evaluated regardless of the context and applied in the runtime.
        * Functions last(), position() and length() are only defined for lists, hence won't be evaluated for the map.
    * A boolean key expression is either a filter of a map key.
        * Any context-dependant references and function calls would automatically cast the expression to a filter key.
        * A statically evaluated boolean would be used as either a filter or a map key and applied in the runtime.
    * Any other expression type resolves to a map key.
        * In case the expression and the map entry key types are incompatible, the lookup silently terminates.
