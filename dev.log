2024-07-28 - Boolean-computing expression analysis

Context enforcement is an approach that helps the interpreter figure out what
specific type it should cast the expression result to. For example, key step
expressions of non-boolean types should be casted to booleans in a list context,
like a property presence expression:

    LIST[@prop]

This expression filters out LIST elements with unset @prop.
@prop could be of any type, but the result of this expression should be casted
to a boolean. In other words, we need to enforce boolean context on this expression.
This comes in contrast to a map context where a context enforcement might lead to an
unexpected result.

A slight complication of the previous case is when we check presence of multiple
properties:

    LIST[@foo && @bar]

In this case we've got a binary AND-expression. Both operands are expected to be
boolean expressions, i.e. if @foo is a number and @bar is a string, the interpreter
should enforce the boolean context on both expressions.

Compare this to a comparison boolean expression:

    LIST[@prop >= 42]

In this example @prop should be evaluated to its native type (assuming a number)
and the comparison expression would naturally evaluate to a boolean. No boolean
context enforcement is required.

Combining the 2 examples above

    LIST[@foo && @bar > 42]

In this case the entire boolean AND-epression is getting evaluated to a boolean.
It also requires both operands to be casted to a boolean. I.e. @foo has be
force-casted to a boolean and the right hand comparison expression evaluates
to a boolean natively, hence no boolean enforcement is required on @bar.

This allows us to conclude the rules of the boolean context enforcement:
1. List context requires an enforcement of a boolean-evaluating context.
2.1. Under a boolean context enforcement, any property accessor operator
    should evaluate to a boolean value indicating the presence of the property
    in the context object.
2.2. Non-enforced context should cause a property accessor operator evaluating
    in the native type of the property.
3.1. Boolean binary expressions (AND- and OR-) should propagate boolean type
    enforcement to its operands.
3.2. Comparison expressions natively result in a boolean and hence should stop
    the context enforcement propagation.

2024-07-13 - Avoid re-entring visited nodes

Assume the following root message:

R
  - L: [ A, B, C ]

Given a path: "//path", the root message visit sequence would be the following:

Assume, the path matches B.

0.  Schedule R with // {admit}
1.  Visit R with // {from 0}
2.  Schedule L with // {admit}
3.  Schedule L with path {admit}
4.  Visit L with // {from 2}
5.  Schedule L with path {skip/3}
6.  Schedule A with // {admit}
7.  Schedule B with // {admit}
8.  Schedule C with // {admit}
9.  Visit L with path {from 3} -> yields B
10. Visit A with // {from 6}
11. Schedule A with path {admit}
12. Visit B with // {from 7}
13. Schedule B with path {admit}
14. Visit C with // {from 8}
15. Schedule C with path {admit}
16. Visit A with path {from 10}
17. Visit B with path {from 11} -> yields B
18. Visit C with path {from 12}

The problem is in this double dispatch leading to a duplicated B in the response.

2024-07-12 - Recusrive descent lookup

Implementing // path operator (SlashSlash).

The algoritm is the following:
Given a root node R and a recursive descent path in a form: "//P".
    Note: Defining a root node A with a direct or indirect
    descending node B and a path in a form "A//B" is trivially
    equivalent to the statement above.
The selector algoritm should perform a recursive descent traversal
of the entire R node tree and collect all nodes (be it: messages,
list elements, map values) matching the selector P.

Consider the following node tree:
R
  - A
    - B
    - C
      - D
        - B
  - B
In this case the recursive descent selector must return all nodes
matching B in total (expanded paths: R/A/B, R/A/C/D/B, R/B).

2024-06-20 - Expression grammar

Expressions could be of 3 types:
* Boolean
* String
* Number(int64)

The following grammar would be used to parse expressions:
```
boolean = "true" | "false"
string = '"' [^"]* '"'
number = [0-9]+
identifier = [a-zA-Z_][a-zA-Z0-9_]*
literal = boolean | string | number
property = @identifier
function_call = identifier '(' [expression (',' expression)*] ')'
elementary_expression = literal | property | function_call | unary_expression | '(' expression ')'

unary_expression = unary_operator expression
unary_operator = "!" | "+" | "-"

expression = comparison_expression
comparison_expression = add_expression comparison_operator add_expression
add_expression = mul_expression add_operator mul_expression
mul_expression = elementary_expression mul_operator elementary_expression

comparison_operator = "=" | "!=" | "<" | "<=" | ">" | ">="
add_operator = "+" | "-", "&&", "||"
mul_operator = "*" | "/"

```


2024-06-18 - On KeyQueryStep and AttributeFilterQueryStep

Key operator is the most complicated step in XPath.

Syntax: `context[key_expression]`


There are effectively 3 distinct kinds of keys:
* Index keys.
    * Evaluates to an integer.
    * Resolves a list to a single element (or an empty set).
    * Examples:
        * "/foo[3]": 3rd element of foo.
        * "/foo[last()]": last element of foo.
        * "/foo[length() - 1]": another way to get the last element of foo.
* Filter keys.
    * Evaluates to a boolean.
    * Filters a list to another list.
    * Examples:
        * "/foo[@bar>10]": elements of foo with bar > 10.
        * "/foo[position() < 3]": first 2 elements of foo.
        * "/foo[position() > 3]": elements of foo after the first 3.
* Map keys.
    * Evaluates to a primitive that would be coalesced to the map key type.
    * Resolves a map to a single element (or an empty set).
    * Examples:
        * "/foo['baz']": map element of foo with a string key baz.
        * "/foo[true]": map element of foo with boolean key true.
        * "/foo[123 + 456]: map element of foo with a numeric key 579.

The following rules apply:
    * Filter keys are chainable.
        * "/foo[@bar>10][position() < 3]" works as AND.
    * Filter keys are element-contextual. The following operators are defined:
        * `.`: current node.
        * `..`: parent node.
        * `@`: attribute prefix.
        * `*`: any attribute.
        * last(): last index of the list.
        * position(): current index of the list element.
    * Index keys are list-contextual. The following operations are defined:
        * length(): length of the list.
        * last(): last index of the list.
        * position(): current index of the list element.
    * Expressions can resolve to one of the following types:
        * Boolean
        * String
        * Numeric

Given the syntax, determining the specific type of a key is a challenge.
In order to conclude the key kind, we use the evaluating expression type.

The following algorithm would be applied:
    * Numeric keys are either index or map keys.
        * A numeric key expression would be evaluated regardless of the context and applied in the runtime.
        * Functions last(), position() and length() are only defined for lists, hence won't be evaluated for the map.
    * A boolean key expression is either a filter of a map key.
        * Any context-dependant references and function calls would automatically cast the expression to a filter key.
        * A statically evaluated boolean would be used as either a filter or a map key and applied in the runtime.
    * Any other expression type resolves to a map key.
        * In case the expression and the map entry key types are incompatible, the lookup silently terminates.
